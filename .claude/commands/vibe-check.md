# Vibe Check: LLM-Generated Code Detection

Detect signs that code was "vibe coded" - hastily generated by an LLM without architectural understanding.

## Red Flags for Vibe Coding

### 1. **Copy-Paste Duplication**
Same logic repeated with minor variations instead of abstraction.
```python
# Vibe coded - copy-pasted 5 times with different variable names
def process_users(): ...
def process_orders(): ...  # Same logic, different entity
def process_items(): ...   # Same logic again
```

### 2. **Over-Engineering Simple Tasks**
Factory patterns, abstract base classes, and dependency injection for scripts that run once.
```python
# Vibe coded - AbstractStrategyFactoryBuilder for a 50-line script
class AbstractDataProcessorFactory(ABC):
    @abstractmethod
    def create_processor(self) -> AbstractProcessor: ...
```

### 3. **Defensive Coding Against Impossible States**
```python
# Vibe coded - checking for None when type system guarantees non-None
def process(data: list[Item]) -> None:
    if data is None:  # Can't be None per type hint
        raise ValueError("data cannot be None")
    if not isinstance(data, list):  # Already typed as list
        raise TypeError("data must be a list")
```

### 4. **Comment Cruft**
```python
# Vibe coded - obvious comments, removed code, TODO graveyards
x = x + 1  # Increment x by 1
# user_id = get_user_id()  # Removed - no longer needed
# TODO: Implement this later
# TODO: Fix this
# TODO: Refactor
```

### 5. **Inconsistent Error Handling**
```python
# Vibe coded - random mix of strategies
try:
    do_a()
except Exception as e:
    print(f"Error: {e}")  # Print and continue

try:
    do_b()
except:  # Bare except
    pass  # Silently ignore

try:
    do_c()
except Exception:
    raise RuntimeError("Failed")  # Re-wrap with less info
```

### 6. **Magic Numbers and Strings**
```python
# Vibe coded - unexplained constants
if retry_count > 3:  # Why 3?
    time.sleep(1.5)  # Why 1.5?
    if len(data) > 10000:  # Why 10000?
```

### 7. **Backwards Compatibility Hacks for New Code**
```python
# Vibe coded - compatibility shims in brand new code
def new_function(x):
    return x

# Keep old name for backwards compatibility
old_function = new_function  # No one is using this yet!
```

### 8. **Unused Imports and Variables**
```python
# Vibe coded - imported "just in case"
import os
import sys
import json
import re
import logging
from typing import Any, Optional, Union, List, Dict, Tuple  # Most unused
```

### 9. **Premature Abstraction**
```python
# Vibe coded - abstraction with single implementation
class DataSource(Protocol):
    def fetch(self) -> Data: ...

class FileDataSource:  # Only implementation, will never have another
    def fetch(self) -> Data: ...
```

### 10. **LLM Tell-Tales**
- Functions named `process_data`, `handle_request`, `do_something`
- Variables named `result`, `data`, `item`, `thing`
- Comments that restate the code: `# Loop through items`
- Docstrings that are just the function signature in prose

## Analysis Instructions

1. **Sample 5-10 files** from different parts of the codebase
2. **Look for patterns** not just individual issues
3. **Check for consistency** - vibe coded projects have inconsistent styles
4. **Verify abstractions are used** - unused abstractions = vibe coded

## Output

```
## Vibe Check Results

**Overall Assessment:** [SOLID / MIXED / VIBE CODED]

### Evidence of Thoughtful Design
- ✓ Consistent error handling pattern in `src/errors.py`
- ✓ Type hints used throughout
- ✓ Clear separation of concerns

### Vibe Coding Indicators
- ✗ 3 copy-pasted functions in `handlers/` (process_x pattern)
- ✗ 12 unused imports across 5 files
- ✗ AbstractFactory for single-use script
- ✗ 47 "TODO" comments with no associated issues

### Verdict
[Explain whether this looks like intentional architecture or generated slop]
```

Run this analysis now.
